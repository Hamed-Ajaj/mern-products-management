// src/index.ts
import express from "express";
import { z } from "zod";
var types = ["query", "params", "body"];
var defaultErrorHandler = (errors, _req, res) => {
  res.status(400).send(errors.map((error) => ({ type: error.type, errors: error.errors.issues })));
};
var globalErrorHandler = defaultErrorHandler;
function isZodType(schema) {
  return !!schema && typeof schema.safeParseAsync === "function";
}
var descriptor = Object.getOwnPropertyDescriptor(express.request, "query");
if (descriptor) {
  Object.defineProperty(express.request, "query", {
    get() {
      if (Object.hasOwn(this, "_query")) return this._query;
      return descriptor?.get?.call(this);
    },
    set(query) {
      this._query = query;
    },
    configurable: true,
    enumerable: true
  });
}
function validate(schemas) {
  const validation = {
    params: isZodType(schemas.params) ? schemas.params : z.strictObject(schemas.params ?? {}),
    query: isZodType(schemas.query) ? schemas.query : z.strictObject(schemas.query ?? {}),
    body: isZodType(schemas.body) ? schemas.body : z.strictObject(schemas.body ?? {})
  };
  return async (req, res, next) => {
    const errors = [];
    for (const type of types) {
      const parsed = await validation[type].safeParseAsync(req[type] ?? {});
      if (parsed.success) req[type] = parsed.data;
      else errors.push({ type, errors: parsed.error });
    }
    if (errors.length > 0) {
      const handler = schemas.handler ?? globalErrorHandler;
      return handler(errors, req, res, next);
    }
    return next();
  };
}
function setGlobalErrorHandler(handler) {
  globalErrorHandler = handler;
}
export {
  validate as default,
  defaultErrorHandler,
  setGlobalErrorHandler
};
//# sourceMappingURL=index.mjs.map